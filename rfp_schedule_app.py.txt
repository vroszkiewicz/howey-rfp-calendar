# --- LIBRARIES ---

import streamlit as st
import pandas as pd
from datetime import datetime, timedelta
import holidays
import requests
from bs4 import BeautifulSoup
from dateutil import parser

# --- PAGE CONFIG ---
# This sets the page title and layout for the application
st.set_page_config(page_title="Howey RFP Calendar Generator", layout="centered")

# --- BRANDING AND HEADING ---
# This will display the Town name and application purpose as stylized HTML headers
st.markdown("<h1 style='text-align: center; ">Town of Howey-in-the-Hills</h1>", unsafe_allow_html=True)
st.markdown("<h2 style='text-align: center; color: #004d7a;'>RFP Schedule Generator</h2>", unsafe_allow_html=True)

# This is an introductory description of what the application will do
st.write("This tool generates an RFP schedule, skipping holidays and non-working days. It will also pull live Town Council meeting dates.")

# --- STEP 1 USER INPUT ---
st.markdown("### Step 1: Enter the date the RFP was posted.")

# This will show a date picker for the user to select the date that the RFP was posted
rfp_posted_date=st.date_input("RFP Posted Date")

# If a date is selected, a list of U.S. federal holidays will generate for that year
if rfp_posted_date:
us_holidays = holidays.US(years=rfp_posted_date.year)
else:
us_holidays = set() # Use empty list if no date is selected

# --- BUSINESS DAY FUNCTION ---
def next_valid_business_day(date, holiday_list):

# This adjusts a given date forward until it lands on a valid business day: (1) Monday to Thursday (i.e., skips Fridays, weekends); (2) not a holiday. Returns an adjusted date and a flag to indicate if it was changed.
adjusted=False
while date.weekday() >= 4 or date in holiday_list:
date += timedelta(days=1)
adjusted=True
return date, adjusted

# --- FUNCTION TO SCRAPE TC MEETINGS ---
fetch_town_council_meetings()

# This connects to the Town's official meetings webpage, finds rows that mention 'Town Council,' and extracts the meeting dates from the HTML. Returns a list of future datetime objects.
try:
# URL of meetings calendar
url="https://www.howey.org/meetings?field_microsite_tid_1=31"
# Fetching page
response=requests.get(url, timeout=10)
if response.status_code !=200:
st.error("Unable to connect to the Town's meeting calendar.")
return[]

# Parsing HTML
soup=BeautifulSoup(response.text, 'html.parser')
rows=soup.find_all("tr", class_=["even", "odd"]) # Table rows with event data

meetings=[]
for row in rows:
if "Town Council" in row.get_text():
link=row.find("a")
if link and "title" in link.attrs:
try: 
dt=parser.parse(link["title"])
if dt > datetime.now():
meetings.append(dt)
except:
continue

return sorted(meetings)

except Exception as e:
st.error(f"Error retrieving council meetings: (e)")
return[]

# --- MAIN SCHEDULE LOGIC ---
# Only run this section if the RFP date was selected

if rfp_posted_date:

# Define events and how many days after the RFP posting they happen
events={
"RFP Posted on Town Website": 0,
"Questions Due to the Town": 7,
"Responses to Questions Posted": 9,
"Proposal Packages Due to the Town": 16,
"Proposal Packages Opened and Evaluated": 16,
"Notice to Award Contract Posted on Town Website": 20,
"Contract Negotiated with the Town": 23,
}

schedule={} # To store final calculated event dates
adjustments={} # To track whether any date was adjusted for holidays or weekends

# To go through each event and calculate its adjusted date
for event, offset in events.items():
raw_date = rfp_posted_date + timedelta(days=offset) # Add offset days
final_date, adjusted = next_valid_business_day(raw_date, us_holidays) # Fix invalid days
schedule[event]=final_date
adjustments[event]=adjusted

# --- STEP 2 COUNCIL MEETING AFTER NEGOTIATION ---
st.markdown("### Step 2: Locate the next Town Council meeting")

# Fetches council meeting dates from the website
meetings = fetch_town_council_meetings()

# Get the date we need to look after
negotiation_date = schedule["Contract Negotiated with Town"]

# If meetings were retrieved
if meetings:
# Find first meeting that comes after contract negotiation
next_meeting=next((m for m in meetings if m > negotiation_date), None)
if next_meeting:
council_final, council_adjusted=next_valid_business_day(next_meeting, us_holidays)
schedule["Town Council Approval of Contract"] = council_final
adjustments["Town Council Approval of Contract"] = council_adjusted
else:
# If scraping fails
st.warning("Unable to retrieve upcoming Town Council meetings.")
schedule["Town Council Approval of Contract"]="Unavailable"
adjustments["Town Council Approval of Contract"]=False

# --- STEP 3 OUTPUT FINAL SCHEDULE ---
st.markdown("### Step 3: Review and Export the Schedule")

# Build a table with events and final dates
df = pd.DataFrame([
{
"Event": event,
"Date": date.strftime('%B %d, %Y') if isinstance(date, datetime) else date,
"Note": "Adjusted for holidays and weekends" if adjustments[event] else ""

}
for event, date in schedule.items()
])

# Show success message and table
st.success("RFP schedule generated successfully."
st.table(df)

# Allow user to download the table as a CSV
csv = df.to_csv(index=False)
st.download_button(
label="Download Schedule as CSV"
data=csv
file_name="rfp_schedule.csv"
mime="text/csv"
)

else:
# If not RFP date is selected yet
st.info("Please select the RFP posted date.")
